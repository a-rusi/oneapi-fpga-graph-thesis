[{"path":"/opt/intel/oneapi/dev-utilities/2021.4.0/include/dpc_common.hpp", "name":"dpc_common.hpp", "has_active_debug_locs":false, "absName":"/opt/intel/oneapi/dev-utilities/2021.4.0/include/dpc_common.hpp", "content":"// Copyright (C) 2020 Intel Corporation\u000A// SPDX-License-Identifier: MIT\u000A\u000A#ifndef _DP_HPP\u000A#define _DP_HPP\u000A\u000A#include <stdlib.h>\u000A#include <exception>\u000A\u000A#include <CL/sycl.hpp>\u000A\u000Anamespace dpc_common {\u000A// This exception handler will catch async exceptions\u000Astatic auto exception_handler = [](cl::sycl::exception_list eList) {\u000A  for (std::exception_ptr const &e : eList) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (std::exception const &e) {\u000A#if _DEBUG\u000A      std::cout << \"Failure\" << std::endl;\u000A#endif\u000A      std::terminate();\u000A    }\u000A  }\u000A};\u000A\u000A// The TimeInterval is a simple RAII class.\u000A// Construct the timer at the point you want to start timing.\u000A// Use the Elapsed() method to return time since construction.\u000A\u000Aclass TimeInterval {\u000A public:\u000A  TimeInterval() : start_(std::chrono::steady_clock::now()) {}\u000A\u000A  double Elapsed() {\u000A    auto now = std::chrono::steady_clock::now();\u000A    return std::chrono::duration_cast<Duration>(now - start_).count();\u000A  }\u000A\u000A private:\u000A  using Duration = std::chrono::duration<double>;\u000A  std::chrono::steady_clock::time_point start_;\u000A};\u000A\u000A};  // namespace dpc_common\u000A\u000A#endif\u000A"}, {"path":"/home/alejandror/parallel-bfs/src/parallel_bfs.cpp", "name":"parallel_bfs.cpp", "has_active_debug_locs":false, "absName":"/home/alejandror/parallel-bfs/src/parallel_bfs.cpp", "content":"#include <CL/sycl.hpp>\u000A#include <vector>\u000A#include <CL/sycl/INTEL/fpga_extensions.hpp>\u000A\u000Ausing namespace sycl;\u000Ausing namespace std;\u000A\u000A#include \"dpc_common.hpp\"\u000A#include <iostream>\u000A#include <fstream>\u000A#include <string>\u000A#include \"sequential_bfs.h\"\u000A\u000A#define NS (1000000000.0) // number of nanoseconds in a second\u000A\u000Astruct edge\u000A{\u000A    int n;\u000A    int m;\u000A};\u000A\u000Avector<vector<int>> create_graph(string filename)\u000A{\u000A\u000A    std::ifstream file;\u000A    file.open(filename);\u000A    int nodes;\u000A    int n;\u000A    int m;\u000A\u000A    file >> nodes;\u000A    vector<edge> edges;\u000A    while (file >> n >> m)\u000A    {\u000A        edges.push_back({n, m});\u000A    }\u000A    file.close();\u000A\u000A    vector<vector<int>> graph(nodes, vector<int>(0));\u000A    for (int i = 0; i < edges.size(); i++)\u000A    {\u000A        int start = edges.at(i).n;\u000A        int end = edges.at(i).m;\u000A        graph[start].push_back(end);\u000A    }\u000A\u000A    return graph;\u000A}\u000A\u000Avector<int> parallel_bfs(vector<vector<int>> &graph)\u000A\u000A{\u000A    //simple graph init\u000A    int nodes = graph.size();\u000A\u000A    // profiling utils\u000A    chrono::high_resolution_clock::time_point t1_host,\u000A        t2_host;\u000A    sycl::cl_ulong t1_kernel, t2_kernel;\u000A    double time_kernel;\u000A    auto my_property_list = property_list{sycl::property::queue::enable_profiling()};\u000A\u000A    // create queue\u000A#if defined(FPGA_EMULATOR)\u000A    sycl::INTEL::fpga_emulator_selector device_selector;\u000A#else\u000A    sycl::INTEL::fpga_selector device_selector;\u000A#endif\u000A    sycl::queue q(device_selector, NULL, my_property_list);\u000A    platform platform = q.get_context().get_platform();\u000A    device my_device = q.get_device();\u000A    std::cout << \"Platform name: \" << platform.get_info<sycl::info::platform::name>().c_str() << std::endl;\u000A    std::cout << \"Device name: \" << my_device.get_info<sycl::info::device::name>().c_str() << std::endl;\u000A    event queue_event;\u000A\u000A    //create parent vector\u000A    vector<int> parent(nodes, -1);\u000A\u000A    // start algorithm\u000A    int source = 0;\u000A    parent[source] = source;\u000A    vector<int> frontier(nodes, -1);\u000A    vector<int> next_frontier(nodes, -1);\u000A    frontier[source] = 1;\u000A    vector<int> finish_vector(1, -1);\u000A\u000A    buffer graph_buffer(graph);                 // graph buffer, to access in algorithm\u000A    buffer parent_buffer(parent);               // parent buffer, to wait until algorithm is done to print result\u000A    buffer frontier_buffer(frontier);           // frontier buffer, reads its nodes in parallel\u000A    buffer next_frontier_buffer(next_frontier); // next frontier buffer, writes permission needed\u000A    buffer finish_vector_buffer(finish_vector); // vector just to flag if execution should be stopped\u000A\u000A    bool all_nodes_visited = false;\u000A    auto nodes_range = range(frontier.size());\u000A\u000A    queue_event = q.submit([&](handler &h) {\u000A        accessor graph_access(graph_buffer, h, read_only);\u000A        accessor parents_access(parent_buffer, h);\u000A        accessor frontier_access(frontier_buffer, h);\u000A        accessor next_frontier_access(next_frontier_buffer, h);\u000A\u000A        // iterate over the frontier, update node parents\u000A\u000A        h.single_task([=]() {\u000A            bool all_nodes_visited = false;\u000A            for (int iteration = 0; iteration < nodes; iteration++)\u000A            {\u000A                if (!all_nodes_visited)\u000A                {\u000A                    all_nodes_visited = true;\u000A                    for (int i = 0; i < nodes; i++)\u000A                    {\u000A                        if (frontier_access[i] != -1)\u000A                        {\u000A                            for (auto &neighbor : graph_access[i])\u000A                            {\u000A                                if (neighbor != -1)\u000A                                {\u000A                                    parents_access[neighbor] = i;\u000A                                    next_frontier_access[neighbor] = 1;\u000A                                }\u000A                            }\u000A                        }\u000A                    }\u000A                    for (int i = 0; i < nodes; i++)\u000A                    {\u000A                        if (parents_access[i] == -1)\u000A                        {\u000A                            all_nodes_visited = false;\u000A                        }\u000A                        frontier_access[i] = next_frontier_access[i];\u000A                        next_frontier_access[i] = -1;\u000A                    }\u000A                }\u000A            }\u000A        });\u000A    });\u000A    q.wait();\u000A\u000A    // Report kernel execution time and throughput\u000A    t1_kernel = queue_event.get_profiling_info<sycl::info::event_profiling::command_start>();\u000A    t2_kernel = queue_event.get_profiling_info<sycl::info::event_profiling::command_end>();\u000A    time_kernel = (t2_kernel - t1_kernel) / NS;\u000A    std::cout << \"Kernel execution time: \" << time_kernel << \" seconds\" << std::endl;\u000A\u000A    host_accessor read_parent(parent_buffer, read_only);\u000A    for (int i = 0; i < parent.size(); i++)\u000A    {\u000A        std::cout << read_parent[i] << \",\";\u000A    }\u000A\u000A    return parent;\u000A}\u000A\u000Aint main()\u000A{\u000A    vector<vector<int>> graph = create_graph(\"facebook_combined.txt\");\u000A    vector<int> parallel_result = parallel_bfs(graph);\u000A    vector<int> sequential_result = sequential_bfs(graph);\u000A    for (int i = 0; i < parallel_result.size(); i++)\u000A    {\u000A        int parent = parallel_result[i];\u000A        if (parent != i && parent != -1)\u000A        {\u000A            vector<int> parent_edges = graph[parent];\u000A            if (std::find(parent_edges.begin(), parent_edges.end(), i) == parent_edges.end())\u000A            {\u000A                std::cout << \"Invalid parent found!\" << std::endl;\u000A            }\u000A        }\u000A    }\u000A}"}, {"path":"/home/alejandror/parallel-bfs/src/sequential_bfs.h", "name":"sequential_bfs.h", "has_active_debug_locs":false, "absName":"/home/alejandror/parallel-bfs/src/sequential_bfs.h", "content":"\u000Ausing namespace std;\u000A#include <vector>\u000A#include <queue>\u000A#include <iostream>\u000A\u000Avector<int> sequential_bfs(vector<vector<int>> &graph)\u000A{\u000A    //simple graph init\u000A    int nodes = graph.size();\u000A\u000A    //create parent vector\u000A    vector<int> parent(nodes, -1);\u000A\u000A    // start algorithm\u000A    int source = 0;\u000A    parent[source] = source;\u000A\u000A    std::queue<int> queue;\u000A    queue.push(source);\u000A    while (!queue.empty())\u000A    {\u000A        int node = queue.front();\u000A        queue.pop();\u000A        for (auto &neighbor : graph[node])\u000A        {\u000A            if (parent[neighbor] < 0)\u000A            {\u000A                parent[neighbor] = node;\u000A                queue.push(neighbor);\u000A            }\u000A        }\u000A    }\u000A\u000A    return parent;\u000A}"}]